name: Stakgraph E2E Standalone Test
on:
  pull_request:
    branches:
      - main

jobs:
  run-standalone-e2e-test:
    runs-on: ubuntu-latest
    name: Run e2e standalone tests
    steps:
      - name: Enable docker.host.internal for Ubuntu
        run: |
          pwd && sudo bash -c 'echo "172.17.0.1 host.docker.internal" >> /etc/hosts'

      - name: Checkout from Github
        uses: actions/checkout@v4

      - name: Give Permission
        working-directory: ./mcp
        run: |
          mkdir -p ./.neo4j/plugins
          sudo chown -R 1000:1000 ./.neo4j/plugins
          sudo chmod -R 777 ./.neo4j/plugins  
          sudo chmod -R 777 ./conf

      - name: Run Neo4j
        working-directory: ./mcp
        run: docker compose -f neo4j.yaml up -d

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24.1"

      - name: Verify Go Installation
        run: go version

      - name: Install gopls
        run: go install golang.org/x/tools/gopls@latest

      - name: Verify gopls Installation
        run: |
          echo "$HOME/go/bin" >> $GITHUB_PATH
          gopls version

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Verify Node.js Installation
        run: node -v

      - name: Install TypeScript and TypeScript LSP
        run: |
          npm install -g typescript typescript-language-server
          echo "$HOME/.npm-global/bin" >> $GITHUB_PATH

      - name: Verify TypeScript Installation
        run: |
          tsc --version
          typescript-language-server --version

      - name: Wait for Neo4j to be Ready
        run: |
          echo "Waiting for Neo4j to be healthy..."
          timeout 300s sh -c '
          until docker inspect --format "{{json .State.Health.Status }}" neo4j.sphinx | grep -q "healthy"; do
            echo "Neo4j is not ready yet..."
            sleep 10
          done'
          echo "Neo4j is healthy!"

      - name: Start Rust Standalone Server
        run: |
          export TEST_REF_ID=1
          export USE_LSP=0
          cargo run --bin standalone --features neo4j > standalone.log 2>&1 &
          echo $! > standalone.pid

      - name: Wait for Rust server
        run: |
          tail -n +1 -f standalone.log &
          npx wait-on http://localhost:7799 -t 600000

      - name: Prepare Node Server
        working-directory: ./mcp
        run: yarn install

      - name: Install dependencies in src/aieo
        working-directory: ./mcp
        run: cd src/aieo && yarn

      - name: Start Node Server
        working-directory: ./mcp
        run: |
          export TEST_REF_ID=1 \n          export USE_STAGEHAND=false
          yarn run dev > server.log 2>&1 &

      - name: Wait for Node server
        run: |
          tail -n +1 -f ./mcp/server.log &
          npx wait-on http://localhost:3000 -t 120000

      - name: Ingest repo data with standalone server
        run: |
          curl -X POST \
          -H "Content-Type: application/json" \
          -d '{"repo_url": "https://github.com/stakwork/demo-repo.git"}' \
          http://localhost:7799/ingest

      - name: Test API Response
        working-directory: ./mcp
        run: |
          sleep 10
          curl "http://localhost:3000/map?name=App&node_type=Function" -o ./testing/actual-map-response.html

      - name: Compare actual and expected output
        working-directory: ./mcp
        run: |
          ACTUAL_MAP_FILE="./testing/actual-map-response.html"
          EXPECTED_MAP_FILE="./testing/map.html"

          SORTED_ACTUAL_MAP_FILE="/tmp/sorted_actual.html"
          SORTED_EXPECTED_MAP_FILE="/tmp/sorted_expected.html"

          sed '1d;$d' "$ACTUAL_MAP_FILE" | sed 's/^[[:space:]]*[├└│┬─][├└│┬─[:space:]]*//' | sort > "$SORTED_ACTUAL_MAP_FILE"
          sed '1d;$d' "$EXPECTED_MAP_FILE" | sed 's/^[[:space:]]*[├└│┬─][├└│┬─[:space:]]*//' | sort > "$SORTED_EXPECTED_MAP_FILE"

          if diff --color=always -u "$SORTED_EXPECTED_MAP_FILE" "$SORTED_ACTUAL_MAP_FILE"; then
            echo "✅ Output matches expected"
          else
            echo "❌ Output does not match expected"
            exit 1
          fi
      - name: Check NodeType Endpoint
        working-directory: ./mcp
        run: |
          curl -s -X GET "http://localhost:3000/nodes?node_type=Endpoint&output=json" -o ./testing/actual-nodes-endpoint.json
          echo "$(<./testing/actual-nodes-endpoint.json)"

      - name: Compare NodeType Response with Expected Output
        working-directory: ./mcp
        run: |
          ACTUAL_NODETYPE_ENDPOINT_FILE="./testing/actual-nodes-endpoint.json"
          EXPECTED_NODETYPE_ENDPOINT_FILE="./testing/nodes-endpoint.json"

          SORTED_ACTUAL_NODETYPE_ENDPOINT_FILE="/tmp/sorted_actual_endpoint.json"
          SORTED_EXPECTED_NODETYPE_ENDPOINT_FILE="/tmp/sorted_expected_endpoint.json"

          jq --sort-keys . "$ACTUAL_NODETYPE_ENDPOINT_FILE" > "$SORTED_ACTUAL_NODETYPE_ENDPOINT_FILE"
          jq --sort-keys . "$EXPECTED_NODETYPE_ENDPOINT_FILE" > "$SORTED_EXPECTED_NODETYPE_ENDPOINT_FILE"

          if diff --color=always -u "$SORTED_EXPECTED_NODETYPE_ENDPOINT_FILE" "$SORTED_ACTUAL_NODETYPE_ENDPOINT_FILE"; then
            echo "Nodetypes Response matches expected output ✅"
          else
            echo "Nodetypes Response does NOT match expected output ❌"
            exit 1
          fi

      - name: Check Fulltext Search
        working-directory: ./mcp
        run: |
          curl -s -X GET "http://localhost:3000/search?query=NewRouter&output=snippet" | \
          perl -0777 -ne '
            my @snippets = split /(?=<snippet>)/, $_;
            shift @snippets if $snippets[0] !~ /<snippet>/;
            print join("", sort @snippets);
          ' > ./testing/actual-fulltext-search.txt
          echo "$(<./testing/actual-fulltext-search.txt)"

      - name: Compare Fulltext Search Response with Expected Output
        working-directory: ./mcp
        run: |
          ACTUAL_FULLTEXT_FILE="./testing/actual-fulltext-search.txt"
          EXPECTED_FULLTEXT_FILE="./testing/fulltext-search-response.txt"

          if diff -q "$ACTUAL_FULLTEXT_FILE" "$EXPECTED_FULLTEXT_FILE"; then
            echo "Response matches expected output ✅"
          else
            echo "Response does NOT match expected output ❌"
            exit 1
          fi
      - name: Embed code with standalone server and wait for completion
        run: |
          for i in {1..10}; do
            resp=$(curl -s -X POST "http://localhost:7799/embed_code")
            echo "Embed code response: $resp"
            if echo "$resp" | grep -q '"status":"completed"'; then
              echo "Embedding completed!"
              break
            fi
            echo "Embedding not done yet, waiting..."
            sleep 10
          done

      - name: Check Vector Search (Standalone)
        working-directory: ./mcp
        run: |
          curl -s -X POST "http://localhost:7799/search?query=NewRouter&node_types=Function&limit=5" \
            -o ./testing/actual-vector-search-response.json
          echo "$(<./testing/actual-vector-search-response.json)"

      - name: Compare Vector Search Response with Expected Output
        working-directory: ./mcp
        run: |
          ACTUAL_VECTOR_FILE="./testing/actual-vector-search-response.json"
          EXPECTED_VECTOR_FILE="./testing/vector-search-response.json"

          # Remove "score" from both actual and expected
          jq 'map(del(.score))' "$ACTUAL_VECTOR_FILE" > /tmp/actual_no_score.json
          jq 'map(del(.score))' "$EXPECTED_VECTOR_FILE" > /tmp/expected_no_score.json

          # Sort for stable comparison
          jq --sort-keys . /tmp/actual_no_score.json > /tmp/sorted_actual_vector.json
          jq --sort-keys . /tmp/expected_no_score.json > /tmp/sorted_expected_vector.json

          if diff --color=always -u /tmp/sorted_expected_vector.json /tmp/sorted_actual_vector.json; then
            echo "Vector search response matches expected output ✅"
          else
            echo "Vector search response does NOT match expected output ❌"
            exit 1
          fi

      - name: Cleanup
        if: always()
        run: |
          if [ -f standalone.pid ]; then
            kill $(cat standalone.pid) || true
          fi
          pkill -f "yarn run dev" || true
